<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>0223_Note_cs61a</title>
    <link rel="stylesheet" href="css/baisc.css">
    <link rel="stylesheet" href="css/nextImportant0216.css">
</head>
<body>
    <!-- 前一天 Start -->
    <H4 style="position: fixed;top:1px;left: 50%;"><a href="0222_Note_cs61a.html">前一天的努力</a></H4>
    <!-- 前一天 End -->
    <!-- 日期顶部Start -->
    <h1>2023年2月23日开始</h1>
    <!-- 日期顶部End -->
    <!-- 右上角Index Start -->
    <div class="index_itself">
        <ol>
            <li><a href="#Syntax">Scheme-Syntax Start</a></li>
        </ol>
    </div>
     <!-- 右上角Index End -->
     <!-- 前情提要+复习Start -->
    <div>
        <ul>
            <p>NextStep/PreviousNextStep</p>
            <li><a href="https://www.youtube.com/watch?v=QVvdsp21uCk&list=PLwDQt7s1o9J56gIGTA_3Eg9DeWf8nWeqH&index=117">9 04 可变参数</a></li>
            回顾完回去61a了，没做61a4天了！！！！！！python一辈子也专研不完，风头已经过了，重点要是也是java啊
            <a href="#"><h2>采用了新的材料和学习思维：看完，复述和尝试代码，再记录--reflect和记忆,所以少了截图,是经过消化的</h2></a>
        <a href="#"><h3>类推下去，看textbook也是，看完一章或者一节复述，需要挑战自己，就看一二节写第一节递归下去，不挑战是看第一节看完写第一节</h3></a>
        </ul>
    </div>
     <!-- 前情提要+复习End -->
     <!-- 笔记内容Start -->
     <div class="main">
        <!-- Syntax Start -->
        <hr><div >
            <h3 id="Syntax">Syntax Start</h3>
                <div>

                </div>
            <h3>Syntax End</h3>
        </div><hr>
        <!-- Syntax End -->
        <!--  -->
        <hr><div >
            <h3 id="xxx">xxx</h3>
                <div>
                    <H4>input，以逗号分隔</H4>
                    x = input('str_prompt') <br>
                    i = x.split(',') <br>
                    <h4>*args,**kwargs</h4>
                    顺序：*args,default,**kwargs <br>
                    *args: 1,2,3 any position 是任意个数的意思<br>
                    **kwargs:a = 1 , b = 1 ----sum(**kwargs)就是这样call  <br>
                    <h4>传参的（内存）地址问题</h4>
                    如果是a，call_func(a)之后，a在函数内会创建一个新地址，global是本来的地址<br>
                    而如果是list,func(list)之后，函数内部和global都指向的是同一个地址<br>
                    用<span>id(arg)</span>可以输出地址的详细，以数字形式，好像是16位进制
                    <h4>sort</h4>
                    sorted(list) <br>
                    dict.sort(key = lambda x:x['standard'])----x就是dict，这里只是匿名函数 <br>
                    <h4>reduce</h4>
                    from functools import reduce <br>
                    <span>reduce(lambda a,b:a+b,obj[,a_original)可省最后一位</span>  <br>
                    累加累除乘 <br>
                    <h4>filter</h4>
                    <span>filter(lambda a:a>17standard,obj)</span><br>
                    output的type是filter类型 <br>
                    可以转List类型以方便使用<br>
                    <br>filter是筛选，会排除不符合条件的 <br>
                    <h4>map</h4>
                    <span>map(lambda a:a>17standard,obj)</span>
                    output的type是map类型 <br>
                    可以转List类型以方便使用<br>
                    map是直接处理，如这里判断，会输出boolean（转为List后) <br>
                    <h4>闭包</h4>
                    def out(): <br>
                    &nbsp;&nbsp;x = 1     <br>
                    &nbsp;&nbsp;def inner():<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;# x = 2是创建新的x 地址不同<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;##<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;# nonlocal x 这是修改前面的x，地址一样<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;# x = 2 <br>
                    闭包没细说，大概就是这种嵌套内外函数 <br>
                    <h4>import&nbsp;time</h4>
                    &nbsp;&nbsp;<span> time.time()</span>----可以获取当下时间戳1970年1月1日0点UTC时间距今时间,UTC+8是东八区
                    <br>在程序前后分别运行，做差，可计算出程序运行时间
                    <h4>@decorator</h4>
                    @docorator <br>
                    def fun(arg):----->将fun变为out_fun(arg)的arg  <br>
                    arg--------->变为inner_fun(arg)的arg <br>
                    经装饰器装饰后,fun不再是原来的fun,而是inner_fun,（可以print(id(fun))看内存地址证明) <br>
                    作用：开发时候，修改需求，不是再原来改代码，而是用装饰器写，这样如果有其他需要调用原部分的代码的其他东西就不需要重写 <br>
                    虽然fun传进out_fun的arg，不过它的实际地址为inner_fun <br>记住就好 <br>
                    <h4>import</h4>
                    <ul>
                        <li>import py</li>
                        <li>import py as shortcut</li>
                        <li>from py import *</li>
                        <li>from py import def </li>
                        <li>from py import def as shortcut</li>                     
                    </ul>
                    <h4>os/sys/datetime/calendar--- module</h4>
                    用到再看就好了 <br>用calendar.calendar(2023)写了个日历哈哈<br>
                    <h4>hashlib/hmac加密</h4>
                    <a href="Object_oriented_programming_Part/补齐知识/Hmac和hashlib_加密_开发可能用用再说.py">Hmac和hashlib_加密_开发可能用用再说.py</a> <br>
                    copy.deepcopy深复制，copy.copy()是shallowcopy,list只复制一层，而deepcopy全部层数都复制，地址 
                    <h4>uuid</h4>
                    uuid.uuid1或2或3或4或5,4在开发中最常用，可能重复，但概率极低，而1是全球唯一，不需要如此
                </div>
            <h3>Syntax End</h3>
        </div><hr>
        
     </div>
      <!-- 笔记内容End -->
    <!-- 日期底部Start -->
    <h1>2023年2月23日结束</h1>
    <!-- 日期底部End -->
    <!-- 后一天 Start -->
    <H4 style="position: fixed;bottom:1px;left: 50%;"><a href="0224_Note_cs61a.html">后一天的努力</a></H4>
    <!-- 后一天 End -->
</body>
</html>